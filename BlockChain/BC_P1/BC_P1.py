"""BC_Prac_1ipynb.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BQbhJbtoHUTtxu6pTGS2pQgegCIdZzC5

### Aim: Write the following programs for Blockchain in Python

1a. Simple Client Class that generates the private and public key by using built in function in python using 
    RSA algorithm and test it

1b. Transaction class to send and receive money and test it

1c. Create multiple transactions and display them

1d. Create a blockchain, genesis block and execute it

1e. Create a mining function and test it

1f. Add blocks to the minor and dump the blockchain
"""

# pip install pycryptodome

"""### 1c. Create multiple transactions and display them"""

class Transaction:
    def __init__(self, transaction_id, date, amount, description):
        self.transaction_id = transaction_id
        self.date = date
        self.amount = amount
        self.description = description

    def __str__(self):
        return (f"Transaction ID: {self.transaction_id}, "
                f"Date: {self.date}, "
                f"Amount: ${self.amount:.2f}, "
                f"Description: {self.description}")


def create_transaction():
    transaction_id = input("Enter transaction ID: ")
    date = input("Enter transaction date (YYYY-MM-DD): ")
    amount = float(input("Enter transaction amount: "))
    description = input("Enter transaction description: ")
    return Transaction(transaction_id, date, amount, description)


def display_transactions(transactions):
    if not transactions:
        print("No transactions to display.")
    else:
        print("\nTransaction History:")
        for i, transaction in enumerate(transactions, start=1):
            print(f"{i}. {transaction}")


def main():
    transactions = []
    while True:
        print("\nMenu:")
        print("1. Create a new transaction")
        print("2. Display all transactions")
        print("3. Exit")

        choice = input("Enter your choice: ")
        if choice == '1':
            transaction = create_transaction()
            transactions.append(transaction)
            print("Transaction added successfully.")
        elif choice == '2':
            display_transactions(transactions)
        elif choice == '3':
            print("Exiting the program. Goodbye!")
            break
        else:
            print("Invalid choice. Please try again.")


if __name__ == "__main__":
    main()

"""### 1d. Create a blockchain, genesis block and execute it"""

import hashlib
import datetime

class Block:
  def __init__(self,index,timestamp,data,previous_hash):
    self.index=index
    self.timestamp=timestamp
    self.data=data
    self.previous_hash=previous_hash
    self.hash=self.compute_hash()

  def compute_hash(self):
    block_content=f"{self.index}{self.timestamp}{self.data}{self.previous_hash}"
    # Use hashlib.sha256() instead of hashlib.sha26()
    return hashlib.sha256(block_content.encode()).hexdigest()

class Blockchain:
  def __init__(self):
    self.chain=[]
    self.create_genesis_block()

  def create_genesis_block(self):
    genesis_block=Block(0,str(datetime.datetime.now()),"Genesis Block","0")
    self.chain.append(genesis_block)

  def get_last_block(self):
    return self.chain[-1]

  def add_new_block(self,data):
    last_block=self.get_last_block()
    new_block=Block(
        index=last_block.index + 1,
        timestamp=str(datetime.datetime.now()),
        data=data,
        previous_hash=last_block.hash,
    )
    self.chain.append(new_block)

  def is_chain_valid(self):
    for i in range(1,len(self.chain)):
      current_block=self.chain[i]
      previous_block=self.chain[i-1]

      if current_block.hash!=current_block.compute_hash():
        return False
      if current_block.previous_hash!=previous_block.hash:
        return False
    return True

  def display_chain(self):
    for block in self.chain:
      print(f"Index: {block.index}")
      print(f"Timestamp: {block.timestamp}")
      print(f"Data: {block.data}")
      print(f"Hash: {block.hash}")
      print(f"Previous Hash: {block.previous_hash}")
      print("-" * 50)

if __name__ == "__main__":
  blockchain = Blockchain()
  blockchain.add_new_block("Block 1 Data")
  blockchain.add_new_block("Block 2 Data")
  blockchain.add_new_block("Block 3 Data")

  blockchain.display_chain()

  print("Is blockchain valid?", blockchain.is_chain_valid())

"""### 1e. Create a mining function and test it


"""

import hashlib
import datetime

class Block:
  def __init__(self,index,timestamp,data,previous_hash,nonce=0):
    self.index=index
    self.timestamp=timestamp
    self.data=data
    self.previous_hash=previous_hash
    self.nonce = nonce # Initialize nonce here
    self.hash=self.compute_hash()
  def compute_hash(self):
    block_content=f"{self.index}{self.timestamp}{self.data}{self.previous_hash}{self.nonce}"
    # Use hashlib.sha256() instead of hashlib.sha26()
    return hashlib.sha256(block_content.encode()).hexdigest()

class Blockchain:
  def __init__(self,difficulty=2):
    self.chain=[]
    self.difficulty=difficulty
    self.create_genesis_block()
  def create_genesis_block(self):
    genesis_block=Block(0,str(datetime.datetime.now()),"Genesis Block","0")
    self.chain.append(genesis_block)
  def get_last_block(self):
    return self.chain[-1]
  def add_new_block(self,data):
    last_block=self.get_last_block()
    new_block=Block(
        index=last_block.index + 1,
        timestamp=str(datetime.datetime.now()),
        data=data,
        previous_hash=last_block.hash,
    )
    self.mine_block(new_block)
    self.chain.append(new_block)
  def mine_block(self,block):
    print(f"Mining block {block.index}. . .")
    while not block.hash.startswith("0" * self.difficulty):
      block.nonce += 1
      block.hash = block.compute_hash()
    print(f"Block {block.index} mined with nonce {block.nonce}: {block.hash}")
  def is_chain_valid(self):
    for i in range(1,len(self.chain)):
      current_block=self.chain[i]
      previous_block=self.chain[i-1]

      if current_block.hash!=current_block.compute_hash():
        return False
      if current_block.previous_hash!=previous_block.hash:
        return False
    return True
  def display_chain(self):
    for block in self.chain:
      print(f"Index: {block.index}")
      print(f"Timestamp: {block.timestamp}")
      print(f"Data: {block.data}")
      print(f"Hash: {block.hash}")
      print(f"Previous Hash: {block.previous_hash}")
      print(f"Nonce: {block.nonce}")
      print("-" * 50)

if __name__ == "__main__":
  blockchain = Blockchain()
  blockchain.add_new_block("Block 1 Data")
  blockchain.add_new_block("Block 2 Data")
  blockchain.add_new_block("Block 3 Data")

  blockchain.display_chain()

  print("Is blockchain valid?", blockchain.is_chain_valid())

"""### 1f. Add blocks to the miner and dump the blockchain"""

import hashlib
import datetime
import json

class Block:
    def __init__(self, index, timestamp, data, previous_hash, nonce=0):
        self.index = index
        self.timestamp = timestamp
        self.data = data
        self.previous_hash = previous_hash
        self.nonce = nonce  # Initialize nonce here
        self.hash = self.compute_hash()

    def compute_hash(self):
        block_content = f"{self.index}{self.timestamp}{self.data}{self.previous_hash}{self.nonce}"
        # Use hashlib.sha256() instead of hashlib.sha26()
        return hashlib.sha256(block_content.encode()).hexdigest()


class Blockchain:
    def __init__(self, difficulty=2):
        self.chain = []
        self.difficulty = difficulty
        self.create_genesis_block()

    def create_genesis_block(self):
        genesis_block = Block(0, str(datetime.datetime.now()), "Genesis Block", "0")
        self.chain.append(genesis_block)

    def get_last_block(self):
        return self.chain[-1]

    def add_new_block(self, data):
        last_block = self.get_last_block()
        new_block = Block(
            index=last_block.index + 1,
            timestamp=str(datetime.datetime.now()),
            data=data,
            previous_hash=last_block.hash,
        )
        self.mine_block(new_block)
        self.chain.append(new_block)

    def mine_block(self, block):
        print(f"Mining block {block.index}...")
        while not block.hash.startswith("0" * self.difficulty):
            block.nonce += 1
            block.hash = block.compute_hash()
        print(f"Block {block.index} mined with nonce {block.nonce}: {block.hash}")

    def is_chain_valid(self):
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i - 1]

            if current_block.hash != current_block.compute_hash():
                return False
            if current_block.previous_hash != previous_block.hash:
                return False
        return True

    def display_chain(self):
        for block in self.chain:
            print(f"Index: {block.index}")
            print(f"Timestamp: {block.timestamp}")
            print(f"Data: {block.data}")
            print(f"Hash: {block.hash}")
            print(f"Previous Hash: {block.previous_hash}")
            print(f"Nonce: {block.nonce}")
            print("-" * 50)

    def dump_blockchain(self, filename="blockchain.json"):
        blockchain_data = []
        for block in self.chain:
            block_data = {
                "index": block.index,
                "timestamp": block.timestamp,
                "data": block.data,
                "previous_hash": block.previous_hash,
                "hash": block.hash,
                "nonce": block.nonce
            }
            blockchain_data.append(block_data)

        with open(filename, 'w') as f:
            json.dump(blockchain_data, f, indent=4)
        print(f"Blockchain dumped to {filename}")


if __name__ == "__main__":
    blockchain = Blockchain()
    blockchain.add_new_block("Block 1 Data")
    blockchain.add_new_block("Block 2 Data")
    blockchain.add_new_block("Block 3 Data")

    blockchain.dump_blockchain()  # Dump to blockchain.json
    blockchain.display_chain()

    print("Is blockchain valid?", blockchain.is_chain_valid())